---
description: "Comprehensive Git operations with strict process adherence, safety checks, and automated workflow management"
---

# Commit - Automated Git Commit Workflow

Apply the [general coding guidelines](./general.instructions.md) to all Git operations and commit messages.

**Command:** `/commit`

## Purpose

Execute a complete Git commit workflow with automated staging, commit message generation, pushing, and cleanup. This command handles the entire process from staging changes to pushing to the remote repository.

## Usage

```
/commit [optional description]
```

**Examples:**

- `/commit` - Auto-detect changes and create appropriate commit message
- `/commit "Add user authentication feature"` - Use specific description
- `/commit --fix` - Indicate this is a bug fix
- `/commit --feat` - Indicate this is a new feature

## Complete Commit Workflow

This command executes the following steps automatically:

1. **`git add .`** - Stage all changes in the repository
2. **Create commit message file** - Generate a properly formatted commit message
3. **`git commit -F commit-message.txt`** - Commit with the generated message
4. **`git push origin main`** - Push changes to the remote main branch
5. **Delete commit file** - Clean up the temporary commit message file

## Subcommands

### `/commit` - Complete Commit Workflow

Execute the complete commit workflow with automated staging, message generation, commit, push, and cleanup.

**Automated Process:**

1. **Git Add All Changes**
   ```bash
   git add .
   ```
   - Stage all modified, new, and deleted files
   - Include untracked files in the commit
   - Validate that changes are intentional

2. **Generate Commit Message File**
   - Analyze staged changes to determine commit type
   - Create `commit-message.txt` with properly formatted message
   - Follow Conventional Commits specification
   - Include relevant scope and description

3. **Execute Commit**
   ```bash
   git commit -F commit-message.txt
   ```
   - Use the generated commit message file
   - Ensure atomic commit with all staged changes
   - Validate commit success

4. **Push to Remote**
   ```bash
   git push origin main
   ```
   - Push changes to the main branch
   - Handle any push conflicts or issues
   - Confirm successful push

5. **Cleanup**
   ```bash
   rm commit-message.txt
   ```
   - Remove the temporary commit message file
   - Clean up any temporary files created during the process

**Conventional Commit Format:**

```
<type>[optional scope]: <description>

[optional body]

[optional footer(s)]
```

**Types:** feat, fix, docs, style, refactor, perf, test, build, ci, chore

### Commit Message Generation Strategy

**Automatic Detection:**
- Analyze file changes to determine appropriate commit type
- Detect scope based on modified file locations
- Generate descriptive commit messages based on actual changes
- Include breaking change indicators when detected

**Message Structure:**
```
type(scope): description

- Detailed change 1
- Detailed change 2
- Detailed change 3

Footer with issue references and breaking changes
```

**Example Generated Messages:**

```
feat(auth): implement JWT authentication system

- Add JWT token generation and validation
- Create authentication middleware for protected routes
- Implement user login and logout endpoints
- Add password hashing with bcrypt

Closes #123
```

```
fix(ui): resolve button alignment issues in mobile view

- Fix flexbox layout for responsive button groups
- Adjust padding and margins for mobile breakpoints
- Ensure consistent button sizing across screen sizes

Fixes #456
```

### Additional Git Operations

**Note:** This prompt focuses specifically on the automated commit workflow. For other Git operations like branching, merging, and releases, use the appropriate specialized prompts.

## Implementation Workflow

When `/commit` is executed, follow this exact sequence:

```bash
# Step 1: Stage all changes
git add .

# Step 2: Create commit message file (generated by AI)
echo "feat(scope): description

- Change 1
- Change 2

Closes #issue" > commit-message.txt

# Step 3: Commit with the message file
git commit -F commit-message.txt

# Step 4: Push to main branch
git push origin main

# Step 5: Clean up
rm commit-message.txt
```

## Error Handling

### Common Issues and Solutions

**Merge Conflicts:**
- If push fails due to conflicts, fetch and merge latest changes
- Resolve conflicts manually
- Re-run the commit workflow

**Authentication Issues:**
- Ensure Git credentials are properly configured
- Check if SSH keys or personal access tokens are valid
- Verify repository permissions

**Branch Protection:**
- If direct push to main is blocked, create a feature branch
- Push to feature branch and create pull request
- Follow repository's branch protection rules

### Rollback Procedures

If the commit workflow fails:
1. Check Git status: `git status`
2. If commit succeeded but push failed: `git push origin main` manually
3. If commit failed: Review and fix issues, then retry
4. Clean up temporary files: `rm -f commit-message.txt`

**Process:**

1. **Branch Planning**

   - Analyze current branch status
   - Determine appropriate base branch
   - Generate descriptive branch name
   - Validate naming convention compliance

2. **Branch Creation**

   - Ensure clean working directory
   - Create branch from appropriate base
   - Set up tracking relationships
   - Configure branch-specific settings

3. **Workflow Setup**
   - Initialize any required branch-specific configurations
   - Set up CI/CD pipeline associations
   - Configure code review requirements

**Naming Convention:**

```
<type>/<ticket-id>-<brief-description>
```

Examples: `feature/PROJ-123-user-authentication`, `fix/PROJ-456-memory-leak`

### `/git issue` - GitHub Issue Generation

Generate comprehensive GitHub issues from current development context.

**Process:**

1. **Context Analysis**

   - Analyze current codebase state
   - Identify related components
   - Gather relevant error messages/logs
   - Determine issue scope and impact

2. **Issue Template Population**

   - Select appropriate issue template
   - Generate descriptive title and description
   - Add relevant labels and milestones
   - Include reproduction steps if applicable

3. **Documentation Generation**
   - Create detailed problem description
   - Include system environment details
   - Add code examples and error logs
   - Suggest potential solutions or workarounds

**Issue Template Structure:**

```markdown
## Issue Description

[Clear, concise description of the problem or feature request]

## Steps to Reproduce

1. [Step 1]
2. [Step 2]
3. [Step 3]

## Expected Behavior

[What should happen]

## Actual Behavior

[What currently happens]

## Environment

- **OS**: [Operating system]
- **Node Version**: [Version]
- **Browser**: [If applicable]
- **Dependencies**: [Relevant package versions]

## Additional Context

[Screenshots, logs, or other relevant information]

## Proposed Solution

[If available, suggest potential fixes or approaches]
```

### `/git merge` - Safe Branch Merging

Merge branches with comprehensive safety checks, conflict resolution, and cleanup.

**Process:**

1. **Pre-merge Validation**

   - Verify all tests pass on source branch
   - Confirm code review approval
   - Check for merge conflicts
   - Validate CI/CD pipeline status

2. **Merge Strategy Selection**

   - Determine appropriate merge strategy (merge, squash, rebase)
   - Consider project workflow requirements
   - Evaluate commit history preservation needs

3. **Conflict Resolution**

   - Identify and analyze merge conflicts
   - Provide guided resolution strategies
   - Validate resolution completeness
   - Run tests after conflict resolution

4. **Post-merge Cleanup**
   - Delete merged feature branches
   - Update local branch tracking
   - Trigger deployment pipelines if configured
   - Notify relevant stakeholders

**Merge Strategies:**

- **Merge Commit**: Preserves branch history, creates merge commit
- **Squash and Merge**: Combines commits into single commit
- **Rebase and Merge**: Linear history without merge commits

### `/git release` - Release Preparation & Management

Prepare releases with automated changelog generation, versioning, and deployment preparation.

**Process:**

1. **Release Planning**

   - Analyze changes since last release
   - Determine semantic version increment
   - Validate release readiness criteria
   - Check for breaking changes

2. **Version Management**

   - Update version numbers in package files
   - Generate or update changelog
   - Create release branch if needed
   - Tag release appropriately

3. **Documentation Generation**

   - Generate comprehensive changelog
   - Update API documentation
   - Create migration guides for breaking changes
   - Prepare release notes

4. **Release Validation**
   - Run full test suite
   - Validate build processes
   - Check deployment readiness
   - Confirm rollback procedures

**Semantic Versioning:**

- **MAJOR**: Breaking changes
- **MINOR**: New features (backward compatible)
- **PATCH**: Bug fixes (backward compatible)

**Changelog Format:**

```markdown
# Changelog

## [Version] - YYYY-MM-DD

### Added

- New features

### Changed

- Changes in existing functionality

### Deprecated

- Soon-to-be removed features

### Removed

- Removed features

### Fixed

- Bug fixes

### Security

- Security improvements
```

## Safety Checks & Validations

### Pre-operation Checks

- [ ] Working directory is clean
- [ ] Local branch is up to date
- [ ] No uncommitted changes
- [ ] Tests are passing
- [ ] Build is successful

### Code Quality Checks

- [ ] Linting passes
- [ ] Formatting is consistent
- [ ] No TypeScript errors
- [ ] Security vulnerabilities addressed
- [ ] Performance implications reviewed

### Process Validations

- [ ] Conventional commit format
- [ ] Branch naming conventions
- [ ] Pull request requirements met
- [ ] Code review approvals obtained
- [ ] CI/CD pipeline success

## Integration with Project Workflow

### Task Management Integration

- Link commits to specific tasks
- Update task status based on commit activity
- Generate task completion reports
- Track development progress

### CI/CD Pipeline Integration

- Trigger appropriate pipeline stages
- Validate deployment readiness
- Monitor build and test results
- Coordinate release deployments

### Team Collaboration

- Notify relevant team members
- Update project documentation
- Coordinate code review processes
- Manage merge conflicts collaboratively

## Error Handling & Recovery

### Conflict Resolution

- Provide guided conflict resolution
- Suggest resolution strategies
- Validate resolution completeness
- Offer rollback options if needed

### Failed Operations

- Detailed error analysis and reporting
- Suggested remediation steps
- Safe rollback procedures
- Prevention strategies for future occurrences

### Recovery Procedures

- Workspace cleanup after failed operations
- Branch restoration capabilities
- Commit history recovery
- Lost work recovery strategies

## Best Practices

### Commit Hygiene

- Atomic commits with single responsibility
- Descriptive commit messages
- Logical change grouping
- Avoid commits with multiple unrelated changes

### Branch Management

- Short-lived feature branches
- Regular synchronization with main branch
- Clean branch history
- Proper branch cleanup after merging

### Release Management

- Regular, predictable release cycles
- Comprehensive testing before releases
- Clear communication of breaking changes
- Proper versioning and documentation

## Security Considerations

### Sensitive Data Protection

- Scan for accidentally committed secrets
- Validate .gitignore effectiveness
- Check for exposed API keys or passwords
- Ensure proper environment variable usage

### Access Control

- Validate branch protection rules
- Confirm required review processes
- Check merge permissions
- Audit commit signing requirements

## Monitoring & Reporting

### Operation Metrics

- Track commit frequency and patterns
- Monitor branch lifecycle duration
- Measure code review turnaround times
- Analyze merge conflict frequency

### Quality Metrics

- Code review approval rates
- Test coverage trends
- Build success rates
- Security vulnerability resolution times

This comprehensive Git workflow system ensures consistent, safe, and efficient version control operations while maintaining high code quality and team collaboration standards.
